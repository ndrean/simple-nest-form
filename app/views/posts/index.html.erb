
<p id="notice"><%= notice %></p>
<div class="row">
  <h1>Index of Posts</h1>
</div>
<div class="row"> 
  <h5>1) Rendering with a table and iteration with <code>&lt% @posts.each do |post| %></code></h5>
  <br>

<button class="badge badge-info mybadge", id="index_posts">Show Post all</button>



  <table class="table table-dark">
    <thead>
      <tr>
        <th scope="col">Title</th>
        <th scope="col">Body</th>
        <th scope="col" colspan="3"></th>
      </tr>
    </thead>

    <tbody id='posts_list'>
     <%= render 'posts/posts', posts: @posts %>
    </tbody>
  </table>
</div>
<div class="row">
   <%= link_to 'New Post', new_post_path, class:"badge badge-info mybadge" %>
</div>
<div class="row">
 <p>We defined a button to display all the posts. On page load, the list is empty
We defined a JS <code>fetch() GET</code> function that triggers on this button click, 
and points to the URL  `/posts?f=""`. This URL is served by the method 'posts#index'.
We put a query string `f=""` such that we can differenciate the presence of params so
that the method `index` can react differently: an empty array `[]` on page load, and
`Post.all` when 'index' sees some params. Then we render a partial. Note that it is
important to use `locals: {posts: @posts}` for this to work (usually we don't need `locals`).
The JS `fetch()` asks for 'text/html' and parses the response from 'index' into 'text' with <code>response.text()</code>.
Then we just pass this content in the (unsual) form 'text/html' (parsed by Ruby, see in the console/network call) to render in
the view.</p>
<p>Note: we need Turbolinks to be loaded to use the JS methods (see 'application.js')</p>

</pre>
  <div class="col-md-6">
  <pre>
# post_controller.rb
def index
  if params[:f].present?
    @posts = Post.all
    render partial: 'posts/posts', locals: {posts: @posts}, layout: false
  else
  #   # on page load, show nothing
    @posts = []
  end
end
  </pre>
  
  </div>
  <div class="col-md-6">
 

  <pre>
#/packs/components/fetchPosts.js
const fetchPosts = (tag) => {
  document.querySelector(tag).addEventListener("click", (e) => {
    e.preventDefault();
    fetch('/posts?f=""', {
      method: "GET",
      headers: {
        "X-Requested-With": "XMLHttpRequest",
        "Content-Type": "text/html",
        Accept: "text/html",
      },
      credentials: "same-origin",
    })
      .then((response) => response.text())
      .then(
        (content) => (document.querySelector("#posts_list").innerHTML = content)
      );
  });
};

export { fetchPosts };


  </pre>
  </div>
</div>



<br>


<div class="row">
  <h5>2) Other possibility: rendering with <code>&lt%= render @posts %></code> 
  with the partial <em>#views/posts/_post.html.erb</em>. We used <code>style='display:inline-block'</code> 
  to have a flex-like display.</h5>

</div>
<%= link_to 'Show All Articles', articles_path, remote: true, id:"article_btn", class:"badge badge-info mybadge" %>
<p>Wwe present another Ajax method to render. The link `remote: true`above points to the `posts#display_articles` method where
we just defined the `respond_to` to `format :js`,  which renders the view '/posts/display_articles.js.erb'.
Note: we need `insertAdjacentHTML` and not just `innerHTML` for this to work.</p>
<pre>
document.querySelector("#articles_list").innerHTML = ""
document.querySelector("#articles_list").insertAdjacentHTML('afterbegin',
`<%= j render @posts %>`)
</pre>
<div id="articles_list">
  <%= render @posts %>
</div>


